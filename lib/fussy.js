// Generated by CoffeeScript 1.6.3
var NEGATIVE, NEUTRAL, P, POSITIVE, cleanContent, debug, enrich, fs, isString, ngramize, pick, replaceAll, thesaurus, _ngramize,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

thesaurus = require('thesaurus');

pick = require('deck').pick;

debug = function() {};

isString = function(obj) {
  return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
};

P = function(p) {
  if (p == null) {
    p = 0.5;
  }
  return +(Math.random() < p);
};

replaceAll = function(find, replace, str) {
  return str.replace(new RegExp(find, 'g'), replace);
};

exports.cleanContent = cleanContent = function(content) {
  return content.replace(/(?:\.|\?|!)+/g, '.').replace(/\s+/g, ' ').replace(/(?:\\n)+/g, '').replace(/\n+/g, '');
};

enrich = function(words) {
  var categories, category, moreWords, similarWord, similarWords, test, word, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;
  moreWords = [];
  for (_i = 0, _len = words.length; _i < _len; _i++) {
    word = words[_i];
    similarWords = thesaurus.find(word);
    if (similarWords.length) {
      if (similarWords.length > 3) {
        continue;
      }
      _ref = similarWords.slice(0, 3);
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        similarWord = _ref[_j];
        if (!((2 < (_ref1 = similarWord.length) && _ref1 < 13))) {
          continue;
        }
        if (__indexOf.call(moreWords, similarWord) >= 0) {
          continue;
        }
        moreWords.push(similarWord);
      }
    } else {
      test = Number(word);
      if (!(!isNaN(test) && isFinite(test))) {
        continue;
      }
      categories = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000];
      for (_k = 0, _len2 = categories.length; _k < _len2; _k++) {
        category = categories[_k];
        if (test < category) {
          moreWords.push("less_than_" + category);
          break;
        }
      }
      _ref2 = categories.reverse();
      for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
        category = _ref2[_l];
        if (test > category) {
          moreWords.push("more_than_" + category);
          break;
        }
      }
    }
  }
  return moreWords;
};

POSITIVE = exports.POSITIVE = +1;

NEGATIVE = exports.NEGATIVE = -1;

NEUTRAL = exports.NEUTRAL = 0;

_ngramize = function(words, n) {
  var gram, grams, i, k, subgrams, v, w, _i, _j, _len, _ref;
  if (!Array.isArray(words)) {
    words = (function() {
      var _i, _len, _ref, _results;
      _ref = words.split(' ');
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        w = _ref[_i];
        if (w.length < 3) {
          continue;
        }
        _results.push(w);
      }
      return _results;
    })();
  }
  grams = {};
  if (n < 2) {
    for (_i = 0, _len = words.length; _i < _len; _i++) {
      w = words[_i];
      grams["" + w] = Array.isArray(w) ? w : [w];
    }
    return grams;
  }
  for (i = _j = 0, _ref = words.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
    gram = words.slice(i, i + n);
    subgrams = _ngramize(gram, n - 1);
    for (k in subgrams) {
      v = subgrams[k];
      grams[k] = v;
    }
    if (i > words.length - n) {
      break;
    }
    grams["" + gram] = gram;
  }
  return grams;
};

ngramize = function(words, n) {
  var ngram, _i, _len, _ref, _results;
  _ref = Object.keys(_ngramize(words, n));
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    ngram = _ref[_i];
    _results.push(ngram.split(",").sort().toString());
  }
  return _results;
};

exports.Engine = (function() {
  function Engine(opts) {
    var _ref, _ref1, _ref2, _ref3, _ref4;
    if (opts == null) {
      opts = {};
    }
    if (isString(opts)) {
      debug("loading '" + opts + "'..");
      opts = JSON.parse(fs.readFileSync(opts, 'utf8'));
    }
    this.stringSize = (_ref = opts.stringSize) != null ? _ref : [0, 30];
    this.ngramSize = (_ref1 = opts.ngramSize) != null ? _ref1 : 3;
    this.debug = (_ref2 = opts.debug) != null ? _ref2 : false;
    this.sampling = (_ref3 = opts.sampling) != null ? _ref3 : 0.3;
    debug = this.debug ? console.log : function() {};
    this.profiles = (_ref4 = opts.profiles) != null ? _ref4 : {};
  }

  Engine.prototype.multiplyFacets = function(content, facets) {
    var a, b, facet, synonym, words, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;
    if (facets == null) {
      facets = [];
    }
    words = content.split(' ');
    for (_i = 0, _len = facets.length; _i < _len; _i++) {
      a = facets[_i];
      for (_j = 0, _len1 = facets.length; _j < _len1; _j++) {
        b = facets[_j];
        facet = [a, b].sort().toString();
        if (a === b) {
          continue;
        }
        if (!P(this.sampling)) {
          continue;
        }
        facets.push(facet);
      }
    }
    _ref = enrich(words);
    for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
      synonym = _ref[_k];
      _ref1 = this.ngramize(synonym);
      for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
        facet = _ref1[_l];
        facets.push(facet);
      }
    }
    return facets;
  };

  Engine.prototype.ngramize = function(words) {
    return ngramize(words, this.ngramSize);
  };

  Engine.prototype.pushEvent = function(event) {
    var alreadyAdded, content, facet, profile, _i, _len, _ref, _ref1, _ref2;
    if (event.signal === NEUTRAL) {
      debug("signal is neutral, ignoring");
      return;
    }
    if (this.profiles[event.profile] == null) {
      debug("creating profile for " + event.profile);
      this.profiles[event.profile] = {};
    }
    profile = this.profiles[event.profile];
    debug("updating profile " + event.profile + "..");
    content = cleanContent(event.content);
    alreadyAdded = {};
    _ref = this.multiplyFacets(content, this.ngramize(content));
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      facet = _ref[_i];
      if (!((this.stringSize[0] < (_ref1 = facet.length) && _ref1 < this.stringSize[1]))) {
        continue;
      }
      if (facet in alreadyAdded) {
        continue;
      }
      alreadyAdded[facet] = profile[facet] = event.signal + ((_ref2 = profile[facet]) != null ? _ref2 : 0);
    }
    return this;
  };

  Engine.prototype.prune = function(min, max) {
    var facet, facets, profile, _, _ref, _ref1;
    _ref = this.profiles;
    for (profile in _ref) {
      facets = _ref[profile];
      for (facet in facets) {
        _ = facets[facet];
        facets[facet] = facets[facet] - 1;
        if ((min < (_ref1 = facets[facet]) && _ref1 < max)) {
          delete facets[facet];
        }
      }
    }
    return this;
  };

  Engine.prototype.rateProfiles = function(content, opts) {
    var facet, facets, filter, id, limit, profile, results, score, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
    if (opts == null) {
      opts = {};
    }
    filter = (_ref = opts.profiles) != null ? _ref : [];
    limit = opts.limit;
    results = [];
    content = cleanContent(content);
    facets = [];
    _ref1 = this.multiplyFacets(content, this.ngramize(content));
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      facet = _ref1[_i];
      if (__indexOf.call(facets, facet) >= 0) {
        continue;
      }
      facets.push(facet);
    }
    _ref2 = this.profiles;
    for (id in _ref2) {
      profile = _ref2[id];
      if (filter.length && __indexOf.call(filter, id) < 0) {
        continue;
      }
      score = 0;
      for (_j = 0, _len1 = facets.length; _j < _len1; _j++) {
        facet = facets[_j];
        score += (_ref3 = profile[facet]) != null ? _ref3 : 0;
      }
      results.push([id, score]);
      if (limit == null) {
        continue;
      }
      if (--limit <= 0) {
        break;
      }
    }
    results.sort(function(a, b) {
      return b[1] - a[1];
    });
    return results;
  };

  Engine.prototype.rateContents = function(id, contents) {
    var alreadyAdded, content, facet, profile, score, top, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    profile = (_ref = this.profiles[id]) != null ? _ref : {};
    top = [];
    id = 0;
    for (_i = 0, _len = contents.length; _i < _len; _i++) {
      content = contents[_i];
      score = 0;
      alreadyAdded = {};
      _ref1 = this.multiplyFacets(content, this.ngramize(content));
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        facet = _ref1[_j];
        if (facet in alreadyAdded) {
          continue;
        }
        score += (_ref2 = profile[facet]) != null ? _ref2 : 0;
        alreadyAdded[facet] = true;
      }
      top.push([content, score]);
    }
    top.sort(function(a, b) {
      return b[1] - a[1];
    });
    return top;
  };

  Engine.prototype.save = function(filePath) {
    var facet, facets, profile, remaining_facets, remaining_profiles, weight, write, _ref;
    if (filePath == null) {
      throw "Error, no file path given";
    }
    write = function(x) {
      return fs.appendFileSync(filePath, x.toString() + '\n');
    };
    fs.writeFileSync(filePath, '{\n');
    write("  \"stringSize\": [" + this.stringSize + "],");
    write("  \"ngramSize\": " + this.ngramSize + ",");
    write("  \"profiles\": {");
    remaining_profiles = Object.keys(this.profiles).length;
    _ref = this.profiles;
    for (profile in _ref) {
      facets = _ref[profile];
      write("    \"" + profile + "\": {");
      remaining_facets = Object.keys(facets).length;
      for (facet in facets) {
        weight = facets[facet];
        write("      \"" + facet + "\": " + weight + (--remaining_facets > 0 ? ',' : ''));
      }
      write("    }" + (--remaining_profiles > 0 ? ',' : ''));
    }
    return write("  }\n}");
  };

  return Engine;

})();
