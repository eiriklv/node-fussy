// Generated by CoffeeScript 1.6.3
(function() {
  var NEGATIVE, NEUTRAL, P, POSITIVE, cleanContent, debug, emptyThesaurus, fs, isString, ngramize, numerize, pick, replaceAll, _ngramize,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  pick = require('deck').pick;

  debug = function() {};

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  P = function(p) {
    if (p == null) {
      p = 0.5;
    }
    return +(Math.random() < p);
  };

  replaceAll = function(find, replace, str) {
    return str.replace(new RegExp(find, 'g'), replace);
  };

  POSITIVE = exports.POSITIVE = +1;

  NEGATIVE = exports.NEGATIVE = -1;

  NEUTRAL = exports.NEUTRAL = 0;

  emptyThesaurus = {
    find: function() {
      return [];
    }
  };

  _ngramize = function(words, n) {
    var gram, grams, i, k, subgrams, v, w, _i, _j, _len, _ref;
    if (!Array.isArray(words)) {
      words = (function() {
        var _i, _len, _ref, _results;
        _ref = words.split(' ');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          w = _ref[_i];
          if (w.length < 3) {
            continue;
          }
          _results.push(w);
        }
        return _results;
      })();
    }
    grams = {};
    if (n < 2) {
      for (_i = 0, _len = words.length; _i < _len; _i++) {
        w = words[_i];
        grams["" + w] = Array.isArray(w) ? w : [w];
      }
      return grams;
    }
    for (i = _j = 0, _ref = words.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
      gram = words.slice(i, i + n);
      subgrams = _ngramize(gram, n - 1);
      for (k in subgrams) {
        v = subgrams[k];
        grams[k] = v;
      }
      if (i > words.length - n) {
        break;
      }
      grams["" + gram] = gram;
    }
    return grams;
  };

  ngramize = function(words, n) {
    var ngram, ngrams, splitted, _i, _len, _ref;
    ngrams = {};
    _ref = Object.keys(_ngramize(words, n));
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      ngram = _ref[_i];
      splitted = ngram.split(",");
      ngrams[splitted.join(" ").toString()] = splitted.length / n;
    }
    return ngrams;
  };

  numerize = function(sentence) {
    var categories, category, numeric, test, word, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    numeric = {};
    _ref = sentence.split(" ");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      word = _ref[_i];
      test = Number(word);
      if (!(!isNaN(test) && isFinite(test))) {
        continue;
      }
      categories = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000];
      for (_j = 0, _len1 = categories.length; _j < _len1; _j++) {
        category = categories[_j];
        if (test < category) {
          numeric["less_than_" + category] = 0.5;
          break;
        }
      }
      _ref1 = categories.reverse();
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        category = _ref1[_k];
        if (test > category) {
          numeric["more_than_" + category] = 0.5;
          break;
        }
      }
    }
    return numeric;
  };

  cleanContent = function(content) {
    content = content.replace(/(&[a-zA-Z]+;|\\t)/g, ' ');
    content = content.replace(/(?:\.|\?|!)+/g, '.');
    content = content.replace(/\s+/g, ' ');
    content = content.replace(/(?:\\n)+/g, '');
    content = content.replace(/\n+/g, '');
    return content;
  };

  exports.Engine = (function() {
    function Engine(opts) {
      var _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      if (opts == null) {
        opts = {};
      }
      if (isString(opts)) {
        debug("loading '" + opts + "'..");
        opts = JSON.parse(fs.readFileSync(opts, 'utf8'));
      }
      this.stringSize = (_ref = opts.stringSize) != null ? _ref : [0, 30];
      this.ngramSize = (_ref1 = opts.ngramSize) != null ? _ref1 : 3;
      this.debug = (_ref2 = opts.debug) != null ? _ref2 : false;
      this.sampling = (_ref3 = opts.sampling) != null ? _ref3 : 0.3;
      debug = this.debug ? console.log : function() {};
      this.profiles = (_ref4 = opts.profiles) != null ? _ref4 : {};
      this.network = (_ref5 = opts.network) != null ? _ref5 : {};
      this.database = (function() {
        var backend, params, uri, _ref6, _ref7;
        uri = (_ref6 = opts.database) != null ? _ref6 : "://";
        _ref7 = uri.split("://"), backend = _ref7[0], params = _ref7[1];
        if (backend === 'redis') {
          return debug("redis not supported yet, but no big deal.");
        }
      })();
    }

    Engine.prototype.extractFacetsFromRawContent = function(raw) {
      var content, facets, k, ngram, ngram_weight, ngrams, synonym, synonym_weight, v, _ref, _ref1, _ref2, _ref3;
      content = cleanContent(raw);
      ngrams = {};
      _ref = ngramize(content, this.ngramSize);
      for (k in _ref) {
        v = _ref[k];
        ngrams[k] = v;
      }
      _ref1 = numerize(content);
      for (k in _ref1) {
        v = _ref1[k];
        ngrams[k] = v;
      }
      facets = {};
      for (ngram in ngrams) {
        ngram_weight = ngrams[ngram];
        if (!((this.stringSize[0] < (_ref2 = ngram.length) && _ref2 < this.stringSize[1]))) {
          continue;
        }
        if (ngram in this.network) {
          _ref3 = this.network[ngram];
          for (synonym in _ref3) {
            synonym_weight = _ref3[synonym];
            if (synonym in facets) {
              continue;
            }
            facets[synonym] = ngram_weight * synonym_weight;
          }
        }
        facets[ngram] = ngram_weight;
      }
      return facets;
    };

    Engine.prototype.pushEvent = function(event) {
      var facet, profile, weight, _ref, _ref1;
      if (event.signal === NEUTRAL) {
        debug("signal is neutral, ignoring");
        return;
      }
      if (this.profiles[event.profile] == null) {
        debug("creating profile for " + event.profile);
        this.profiles[event.profile] = {};
      }
      profile = this.profiles[event.profile];
      debug("updating profile " + event.profile + "..");
      _ref = this.extractFacetsFromRawContent(event.content);
      for (facet in _ref) {
        weight = _ref[facet];
        profile[facet] = event.signal * weight + ((_ref1 = profile[facet]) != null ? _ref1 : 0);
      }
      return this;
    };

    Engine.prototype.prune = function(min, max) {
      var facet, facets, profile, _, _ref, _ref1;
      _ref = this.profiles;
      for (profile in _ref) {
        facets = _ref[profile];
        for (facet in facets) {
          _ = facets[facet];
          facets[facet] = facets[facet] - 1;
          if ((min < (_ref1 = facets[facet]) && _ref1 < max)) {
            delete facets[facet];
          }
        }
      }
      return this;
    };

    Engine.prototype.rateProfiles = function(content, opts) {
      var facet, facets, filter, id, limit, profile, results, score, weight, _ref, _ref1, _ref2;
      if (opts == null) {
        opts = {};
      }
      filter = (_ref = opts.profiles) != null ? _ref : [];
      limit = opts.limit;
      results = [];
      facets = this.extractFacetsFromRawContent(content);
      _ref1 = this.profiles;
      for (id in _ref1) {
        profile = _ref1[id];
        if (filter.length && __indexOf.call(filter, id) < 0) {
          continue;
        }
        score = 0;
        for (facet in facets) {
          weight = facets[facet];
          score += weight * ((_ref2 = profile[facet]) != null ? _ref2 : 0);
        }
        results.push([id, score]);
        if (limit == null) {
          continue;
        }
        if (--limit <= 0) {
          break;
        }
      }
      results.sort(function(a, b) {
        return b[1] - a[1];
      });
      return results;
    };

    Engine.prototype.rateContents = function(id, contents) {
      var content, facet, profile, score, top, weight, _i, _len, _ref, _ref1, _ref2;
      profile = (_ref = this.profiles[id]) != null ? _ref : {};
      top = [];
      id = 0;
      for (_i = 0, _len = contents.length; _i < _len; _i++) {
        content = contents[_i];
        score = 0;
        _ref1 = this.extractFacetsFromRawContent(content);
        for (facet in _ref1) {
          weight = _ref1[facet];
          score += weight * ((_ref2 = profile[facet]) != null ? _ref2 : 0);
        }
        top.push([content, score]);
      }
      top.sort(function(a, b) {
        return b[1] - a[1];
      });
      return top;
    };

    Engine.prototype.save = function(filePath) {
      var facet, facets, profile, remaining_facets, remaining_profiles, weight, write, _ref;
      if (filePath == null) {
        throw "Error, no file path given";
      }
      write = function(x) {
        return fs.appendFileSync(filePath, x.toString() + '\n');
      };
      fs.writeFileSync(filePath, '{\n');
      write("  \"stringSize\": [" + this.stringSize + "],");
      write("  \"ngramSize\": " + this.ngramSize + ",");
      write("  \"profiles\": {");
      remaining_profiles = Object.keys(this.profiles).length;
      _ref = this.profiles;
      for (profile in _ref) {
        facets = _ref[profile];
        write("    \"" + profile + "\": {");
        remaining_facets = Object.keys(facets).length;
        for (facet in facets) {
          weight = facets[facet];
          write("      \"" + facet + "\": " + weight + (--remaining_facets > 0 ? ',' : ''));
        }
        write("    }" + (--remaining_profiles > 0 ? ',' : ''));
      }
      return write("  }\n}");
    };

    return Engine;

  })();

}).call(this);
